import os
import json
import boto3
import logging
from datetime import datetime, timedelta
from botocore.exceptions import ClientError
from botocore.config import Config

# Configure logging
logger = logging.getLogger()
logger.setLevel(os.getenv("LOG_LEVEL", "INFO"))

# Environment variables
TABLE_ROUTINES = os.getenv("TABLE_ROUTINES")

# AWS clients with retry configuration
dynamodb = boto3.resource("dynamodb", config=Config(
    retries={'max_attempts': 3, 'mode': 'adaptive'}
))
table = dynamodb.Table(TABLE_ROUTINES)

def _validate_user_id(user_id: str) -> tuple[bool, str]:
    """Validate user_id parameter"""
    if not user_id or not isinstance(user_id, str):
        return False, "user_id is required and must be a string"
    
    if len(user_id) > 100:
        return False, "user_id must be less than 100 characters"
    
    return True, ""

def _get_user_routine(user_id: str) -> dict:
    """Get the most recent routine for a user"""
    try:
        response = table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key('user_id').eq(user_id),
            ScanIndexForward=False,  # Latest first
            Limit=1
        )
        
        return response['Items'][0] if response['Items'] else None
        
    except ClientError as e:
        logger.error(f"DynamoDB error: {e}")
        return None

def _generate_ics_content(routine: dict) -> str:
    """Generate ICS calendar content from routine"""
    routine_id = routine.get("routine_id", "unknown")
    summary = routine.get("summary", "SheGlow Skincare Routine")
    steps = routine.get("steps", [])
    reminders = routine.get("reminders", ["08:00 AM", "08:00 PM"])
    skin_type = routine.get("skin_type", "")
    concerns = routine.get("concerns", [])
    
    # Build detailed description
    description_parts = [
        f"Personalized skincare routine for {skin_type} skin" if skin_type else "Personalized skincare routine",
        f"Focus areas: {', '.join(concerns)}" if concerns else "",
        "",
        "Routine Steps:"
    ]
    
    # Add steps to description
    for i, step in enumerate(steps, 1):
        time_of_day = step.get("time_of_day", "")
        step_name = step.get("step_name", "")
        product = step.get("product", "")
        instructions = step.get("instructions", "")
        
        step_text = f"{i}. [{time_of_day}] {step_name}"
        if product:
            step_text += f" - {product}"
        if instructions:
            step_text += f"\\n   {instructions[:100]}..."
        
        description_parts.append(step_text)
    
    description_parts.extend([
        "",
        "Consistency is key to healthy, glowing skin!",
        "Generated by SheGlow Concierge"
    ])
    
    description = "\\n".join(description_parts)
    
    # Generate current date for DTSTAMP
    now = datetime.utcnow()
    dtstamp = now.strftime('%Y%m%dT%H%M%SZ')
    
    # Parse reminder times and create events
    events = []
    event_counter = 1
    
    for reminder_time in reminders:
        try:
            # Parse time (e.g., "08:00 AM" or "20:00")
            if "AM" in reminder_time or "PM" in reminder_time:
                time_obj = datetime.strptime(reminder_time, "%I:%M %p")
                time_of_day = "Morning" if "AM" in reminder_time else "Evening"
            else:
                time_obj = datetime.strptime(reminder_time, "%H:%M")
                time_of_day = "Morning" if time_obj.hour < 12 else "Evening"
            
            # Format time for ICS (24-hour format)
            ics_time = time_obj.strftime('%H%M00')
            
            # Create event
            event = f"""BEGIN:VEVENT
UID:{routine_id}-{event_counter}@sheglow.app
DTSTART:20240101T{ics_time}Z
DTEND:20240101T{(time_obj + timedelta(minutes=15)).strftime('%H%M00')}Z
RRULE:FREQ=DAILY
SUMMARY:{time_of_day} Skincare Routine - SheGlow
DESCRIPTION:{description}
CATEGORIES:Health,Beauty,Personal Care
PRIORITY:5
STATUS:CONFIRMED
TRANSP:OPAQUE
DTSTAMP:{dtstamp}
END:VEVENT"""
            
            events.append(event)
            event_counter += 1
            
        except ValueError as e:
            logger.warning(f"Failed to parse reminder time '{reminder_time}': {e}")
            continue
    
    # If no valid events, create default morning and evening events
    if not events:
        events = [
            f"""BEGIN:VEVENT
UID:{routine_id}-morning@sheglow.app
DTSTART:20240101T080000Z
DTEND:20240101T081500Z
RRULE:FREQ=DAILY
SUMMARY:Morning Skincare Routine - SheGlow
DESCRIPTION:{description}
CATEGORIES:Health,Beauty,Personal Care
PRIORITY:5
STATUS:CONFIRMED
TRANSP:OPAQUE
DTSTAMP:{dtstamp}
END:VEVENT""",
            f"""BEGIN:VEVENT
UID:{routine_id}-evening@sheglow.app
DTSTART:20240101T210000Z
DTEND:20240101T211500Z
RRULE:FREQ=DAILY
SUMMARY:Evening Skincare Routine - SheGlow
DESCRIPTION:{description}
CATEGORIES:Health,Beauty,Personal Care
PRIORITY:5
STATUS:CONFIRMED
TRANSP:OPAQUE
DTSTAMP:{dtstamp}
END:VEVENT"""
        ]
    
    # Build complete ICS content
    ics_content = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//SheGlow Concierge//Skincare Routine Calendar//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
X-WR-CALNAME:SheGlow Skincare Routine
X-WR-CALDESC:Your personalized skincare routine reminders
X-WR-TIMEZONE:UTC
{"".join(events)}
END:VCALENDAR"""
    
    return ics_content

def lambda_handler(event, context):
    """Enhanced lambda handler for calendar ICS generation"""
    try:
        # Log request
        logger.info(json.dumps({
            "event": "calendar_ics_request",
            "request_id": context.aws_request_id if context else "local"
        }))
        
        # Extract query parameters
        query_params = event.get('queryStringParameters') or {}
        user_id = query_params.get('user_id')
        
        # Validate user_id
        is_valid, error_msg = _validate_user_id(user_id)
        if not is_valid:
            return {
                "statusCode": 400,
                "headers": {"Content-Type": "application/json"},
                "body": json.dumps({"error": error_msg})
            }
        
        # Get user's most recent routine
        routine = _get_user_routine(user_id)
        if not routine:
            return {
                "statusCode": 404,
                "headers": {"Content-Type": "application/json"},
                "body": json.dumps({
                    "error": "No routines found for this user",
                    "user_id": user_id
                })
            }
        
        # Generate ICS content
        ics_content = _generate_ics_content(routine)
        
        # Log success
        logger.info(json.dumps({
            "event": "calendar_ics_generated",
            "user_id": user_id,
            "routine_id": routine.get("routine_id")
        }))
        
        # Return ICS file
        return {
            "statusCode": 200,
            "headers": {
                "Content-Type": "text/calendar; charset=utf-8",
                "Content-Disposition": f'attachment; filename="sheglow-routine-{user_id}.ics"',
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET, OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type"
            },
            "body": ics_content
        }
        
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return {
            "statusCode": 500,
            "headers": {"Content-Type": "application/json"},
            "body": json.dumps({
                "error": "Internal server error",
                "timestamp": datetime.utcnow().isoformat()
            })
        }